// Code generated by ogen, DO NOT EDIT.

package vnt

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AddPetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddPetOK) encodeFields(e *jx.Encoder) {
	{
		if s.Ok.Set {
			e.FieldStart("ok")
			s.Ok.Encode(e)
		}
	}
}

var jsonFieldsNameOfAddPetOK = [1]string{
	0: "ok",
}

// Decode decodes AddPetOK from json.
func (s *AddPetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddPetOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ok":
			if err := func() error {
				s.Ok.Reset()
				if err := s.Ok.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddPetOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddPetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddPetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddPetReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddPetReq) encodeFields(e *jx.Encoder) {
	{
		if s.VientoItem.Set {
			e.FieldStart("viento_item")
			s.VientoItem.Encode(e)
		}
	}
	{
		if s.ReportResponse.Set {
			e.FieldStart("report_response")
			s.ReportResponse.Encode(e)
		}
	}
}

var jsonFieldsNameOfAddPetReq = [2]string{
	0: "viento_item",
	1: "report_response",
}

// Decode decodes AddPetReq from json.
func (s *AddPetReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddPetReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "viento_item":
			if err := func() error {
				s.VientoItem.Reset()
				if err := s.VientoItem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viento_item\"")
			}
		case "report_response":
			if err := func() error {
				s.ReportResponse.Reset()
				if err := s.ReportResponse.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"report_response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddPetReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddPetReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddPetReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int64(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfError = [2]string{
	0: "code",
	1: "message",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.Code = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetReportResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetReportResponse) encodeFields(e *jx.Encoder) {
	{
		if s.TotalCount.Set {
			e.FieldStart("total_count")
			s.TotalCount.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.Delivery.Set {
			e.FieldStart("delivery")
			s.Delivery.Encode(e)
		}
	}
	{
		if s.RefundAndOthers.Set {
			e.FieldStart("refund_and_others")
			s.RefundAndOthers.Encode(e)
		}
	}
	{
		if s.Service.Set {
			e.FieldStart("service")
			s.Service.Encode(e)
		}
	}
	{
		if s.Final.Set {
			e.FieldStart("final")
			s.Final.Encode(e)
		}
	}
	{
		if s.Result != nil {
			e.FieldStart("result")
			e.ArrStart()
			for _, elem := range s.Result {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetReportResponse = [7]string{
	0: "total_count",
	1: "total",
	2: "delivery",
	3: "refund_and_others",
	4: "service",
	5: "final",
	6: "result",
}

// Decode decodes GetReportResponse from json.
func (s *GetReportResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetReportResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total_count":
			if err := func() error {
				s.TotalCount.Reset()
				if err := s.TotalCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_count\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "delivery":
			if err := func() error {
				s.Delivery.Reset()
				if err := s.Delivery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delivery\"")
			}
		case "refund_and_others":
			if err := func() error {
				s.RefundAndOthers.Reset()
				if err := s.RefundAndOthers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refund_and_others\"")
			}
		case "service":
			if err := func() error {
				s.Service.Reset()
				if err := s.Service.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		case "final":
			if err := func() error {
				s.Final.Reset()
				if err := s.Final.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"final\"")
			}
		case "result":
			if err := func() error {
				s.Result = make([]ReportSumInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReportSumInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Result = append(s.Result, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetReportResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetReportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetReportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSumProficiencyParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSumProficiencyParams) encodeFields(e *jx.Encoder) {
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetSumProficiencyParams = [1]string{
	0: "date",
}

// Decode decodes GetSumProficiencyParams from json.
func (s *GetSumProficiencyParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSumProficiencyParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSumProficiencyParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSumProficiencyParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSumProficiencyParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSumProficiencyParamsDate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSumProficiencyParamsDate) encodeFields(e *jx.Encoder) {
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfGetSumProficiencyParamsDate = [2]string{
	0: "from",
	1: "to",
}

// Decode decodes GetSumProficiencyParamsDate from json.
func (s *GetSumProficiencyParamsDate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSumProficiencyParamsDate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSumProficiencyParamsDate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSumProficiencyParamsDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSumProficiencyParamsDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSumServicesByDayOKApplicationJSON as json.
func (s GetSumServicesByDayOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []GetSumServicesByDayOKItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetSumServicesByDayOKApplicationJSON from json.
func (s *GetSumServicesByDayOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSumServicesByDayOKApplicationJSON to nil")
	}
	var unwrapped []GetSumServicesByDayOKItem
	if err := func() error {
		unwrapped = make([]GetSumServicesByDayOKItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GetSumServicesByDayOKItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSumServicesByDayOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSumServicesByDayOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSumServicesByDayOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSumServicesByDayOKItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSumServicesByDayOKItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("amount")
		e.Float32(s.Amount)
	}
}

var jsonFieldsNameOfGetSumServicesByDayOKItem = [2]string{
	0: "name",
	1: "amount",
}

// Decode decodes GetSumServicesByDayOKItem from json.
func (s *GetSumServicesByDayOKItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSumServicesByDayOKItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float32()
				s.Amount = float32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSumServicesByDayOKItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSumServicesByDayOKItem) {
					name = jsonFieldsNameOfGetSumServicesByDayOKItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSumServicesByDayOKItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSumServicesByDayOKItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Item) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Item) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Sku.Set {
			e.FieldStart("sku")
			s.Sku.Encode(e)
		}
	}
	{
		if s.Ean.Set {
			e.FieldStart("ean")
			s.Ean.Encode(e)
		}
	}
	{
		if s.VientoID.Set {
			e.FieldStart("viento_id")
			s.VientoID.Encode(e)
		}
	}
	{
		if s.Consumption.Set {
			e.FieldStart("consumption")
			s.Consumption.Encode(e)
		}
	}
}

var jsonFieldsNameOfItem = [6]string{
	0: "id",
	1: "name",
	2: "sku",
	3: "ean",
	4: "viento_id",
	5: "consumption",
}

// Decode decodes Item from json.
func (s *Item) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Item to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "sku":
			if err := func() error {
				s.Sku.Reset()
				if err := s.Sku.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sku\"")
			}
		case "ean":
			if err := func() error {
				s.Ean.Reset()
				if err := s.Ean.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ean\"")
			}
		case "viento_id":
			if err := func() error {
				s.VientoID.Reset()
				if err := s.VientoID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viento_id\"")
			}
		case "consumption":
			if err := func() error {
				s.Consumption.Reset()
				if err := s.Consumption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumption\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Item")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Item) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Item) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListTransactionParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListTransactionParams) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("filter")
		s.Filter.Encode(e)
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("page_size")
			s.PageSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfListTransactionParams = [3]string{
	0: "filter",
	1: "page",
	2: "page_size",
}

// Decode decodes ListTransactionParams from json.
func (s *ListTransactionParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListTransactionParams to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "filter":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Filter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filter\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "page_size":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page_size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListTransactionParams")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListTransactionParams) {
					name = jsonFieldsNameOfListTransactionParams[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListTransactionParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListTransactionParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListTransactionParamsFilter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListTransactionParamsFilter) encodeFields(e *jx.Encoder) {
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e)
		}
	}
	{
		if s.OperationType != nil {
			e.FieldStart("operation_type")
			e.ArrStart()
			for _, elem := range s.OperationType {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PostingNumber.Set {
			e.FieldStart("posting_number")
			s.PostingNumber.Encode(e)
		}
	}
	{
		if s.TransactionType.Set {
			e.FieldStart("transaction_type")
			s.TransactionType.Encode(e)
		}
	}
}

var jsonFieldsNameOfListTransactionParamsFilter = [4]string{
	0: "date",
	1: "operation_type",
	2: "posting_number",
	3: "transaction_type",
}

// Decode decodes ListTransactionParamsFilter from json.
func (s *ListTransactionParamsFilter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListTransactionParamsFilter to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "operation_type":
			if err := func() error {
				s.OperationType = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.OperationType = append(s.OperationType, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation_type\"")
			}
		case "posting_number":
			if err := func() error {
				s.PostingNumber.Reset()
				if err := s.PostingNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"posting_number\"")
			}
		case "transaction_type":
			if err := func() error {
				s.TransactionType.Reset()
				if err := s.TransactionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transaction_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListTransactionParamsFilter")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListTransactionParamsFilter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListTransactionParamsFilter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListTransactionParamsFilterDate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListTransactionParamsFilterDate) encodeFields(e *jx.Encoder) {
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfListTransactionParamsFilterDate = [2]string{
	0: "from",
	1: "to",
}

// Decode decodes ListTransactionParamsFilterDate from json.
func (s *ListTransactionParamsFilterDate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListTransactionParamsFilterDate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListTransactionParamsFilterDate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListTransactionParamsFilterDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListTransactionParamsFilterDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Operation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Operation) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
	{
		if s.OperationID.Set {
			e.FieldStart("OperationID")
			s.OperationID.Encode(e)
		}
	}
	{
		if s.OperationType.Set {
			e.FieldStart("OperationType")
			s.OperationType.Encode(e)
		}
	}
	{
		if s.OperationDate.Set {
			e.FieldStart("OperationDate")
			s.OperationDate.Encode(e)
		}
	}
	{
		if s.OperationTypeName.Set {
			e.FieldStart("OperationTypeName")
			s.OperationTypeName.Encode(e)
		}
	}
	{
		if s.DeliveryCharge.Set {
			e.FieldStart("DeliveryCharge")
			s.DeliveryCharge.Encode(e)
		}
	}
	{
		if s.ReturnDeliveryCharge.Set {
			e.FieldStart("ReturnDeliveryCharge")
			s.ReturnDeliveryCharge.Encode(e)
		}
	}
	{
		if s.AccrualsForSale.Set {
			e.FieldStart("AccrualsForSale")
			s.AccrualsForSale.Encode(e)
		}
	}
	{
		if s.SaleCommission.Set {
			e.FieldStart("SaleCommission")
			s.SaleCommission.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("Amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.TransactionType.Set {
			e.FieldStart("TransactionType")
			s.TransactionType.Encode(e)
		}
	}
	{
		if s.PostingID.Set {
			e.FieldStart("PostingID")
			s.PostingID.Encode(e)
		}
	}
	{
		if s.ItemSKU.Set {
			e.FieldStart("ItemSKU")
			s.ItemSKU.Encode(e)
		}
	}
	{
		if s.Services != nil {
			e.FieldStart("Services")
			e.ArrStart()
			for _, elem := range s.Services {
				e.Int64(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfOperation = [14]string{
	0:  "ID",
	1:  "OperationID",
	2:  "OperationType",
	3:  "OperationDate",
	4:  "OperationTypeName",
	5:  "DeliveryCharge",
	6:  "ReturnDeliveryCharge",
	7:  "AccrualsForSale",
	8:  "SaleCommission",
	9:  "Amount",
	10: "TransactionType",
	11: "PostingID",
	12: "ItemSKU",
	13: "Services",
}

// Decode decodes Operation from json.
func (s *Operation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Operation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "OperationID":
			if err := func() error {
				s.OperationID.Reset()
				if err := s.OperationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"OperationID\"")
			}
		case "OperationType":
			if err := func() error {
				s.OperationType.Reset()
				if err := s.OperationType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"OperationType\"")
			}
		case "OperationDate":
			if err := func() error {
				s.OperationDate.Reset()
				if err := s.OperationDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"OperationDate\"")
			}
		case "OperationTypeName":
			if err := func() error {
				s.OperationTypeName.Reset()
				if err := s.OperationTypeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"OperationTypeName\"")
			}
		case "DeliveryCharge":
			if err := func() error {
				s.DeliveryCharge.Reset()
				if err := s.DeliveryCharge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DeliveryCharge\"")
			}
		case "ReturnDeliveryCharge":
			if err := func() error {
				s.ReturnDeliveryCharge.Reset()
				if err := s.ReturnDeliveryCharge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ReturnDeliveryCharge\"")
			}
		case "AccrualsForSale":
			if err := func() error {
				s.AccrualsForSale.Reset()
				if err := s.AccrualsForSale.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"AccrualsForSale\"")
			}
		case "SaleCommission":
			if err := func() error {
				s.SaleCommission.Reset()
				if err := s.SaleCommission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SaleCommission\"")
			}
		case "Amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Amount\"")
			}
		case "TransactionType":
			if err := func() error {
				s.TransactionType.Reset()
				if err := s.TransactionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"TransactionType\"")
			}
		case "PostingID":
			if err := func() error {
				s.PostingID.Reset()
				if err := s.PostingID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PostingID\"")
			}
		case "ItemSKU":
			if err := func() error {
				s.ItemSKU.Reset()
				if err := s.ItemSKU.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ItemSKU\"")
			}
		case "Services":
			if err := func() error {
				s.Services = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int64
					v, err := d.Int64()
					elem = int64(v)
					if err != nil {
						return err
					}
					s.Services = append(s.Services, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Services\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Operation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Operation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Operation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetReportResponse as json.
func (o OptGetReportResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetReportResponse from json.
func (o *OptGetReportResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetReportResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetReportResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetReportResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSumProficiencyParams as json.
func (o OptGetSumProficiencyParams) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetSumProficiencyParams from json.
func (o *OptGetSumProficiencyParams) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetSumProficiencyParams to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetSumProficiencyParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetSumProficiencyParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSumProficiencyParamsDate as json.
func (o OptGetSumProficiencyParamsDate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetSumProficiencyParamsDate from json.
func (o *OptGetSumProficiencyParamsDate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetSumProficiencyParamsDate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetSumProficiencyParamsDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetSumProficiencyParamsDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListTransactionParamsFilterDate as json.
func (o OptListTransactionParamsFilterDate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ListTransactionParamsFilterDate from json.
func (o *OptListTransactionParamsFilterDate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptListTransactionParamsFilterDate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptListTransactionParamsFilterDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptListTransactionParamsFilterDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VientoItem as json.
func (o OptVientoItem) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VientoItem from json.
func (o *OptVientoItem) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVientoItem to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVientoItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVientoItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Posting) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Posting) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
	{
		if s.DeliverySchema.Set {
			e.FieldStart("DeliverySchema")
			s.DeliverySchema.Encode(e)
		}
	}
	{
		if s.OrderDate.Set {
			e.FieldStart("OrderDate")
			s.OrderDate.Encode(e)
		}
	}
	{
		if s.PostingNumber.Set {
			e.FieldStart("PostingNumber")
			s.PostingNumber.Encode(e)
		}
	}
	{
		if s.WarehouseID.Set {
			e.FieldStart("WarehouseID")
			s.WarehouseID.Encode(e)
		}
	}
}

var jsonFieldsNameOfPosting = [5]string{
	0: "ID",
	1: "DeliverySchema",
	2: "OrderDate",
	3: "PostingNumber",
	4: "WarehouseID",
}

// Decode decodes Posting from json.
func (s *Posting) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Posting to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "DeliverySchema":
			if err := func() error {
				s.DeliverySchema.Reset()
				if err := s.DeliverySchema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"DeliverySchema\"")
			}
		case "OrderDate":
			if err := func() error {
				s.OrderDate.Reset()
				if err := s.OrderDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"OrderDate\"")
			}
		case "PostingNumber":
			if err := func() error {
				s.PostingNumber.Reset()
				if err := s.PostingNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PostingNumber\"")
			}
		case "WarehouseID":
			if err := func() error {
				s.WarehouseID.Reset()
				if err := s.WarehouseID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"WarehouseID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Posting")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Posting) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Posting) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReportSumInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReportSumInfo) encodeFields(e *jx.Encoder) {
	{
		if s.ItemName.Set {
			e.FieldStart("item_name")
			s.ItemName.Encode(e)
		}
	}
	{
		if s.Count.Set {
			e.FieldStart("count")
			s.Count.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
}

var jsonFieldsNameOfReportSumInfo = [3]string{
	0: "item_name",
	1: "count",
	2: "amount",
}

// Decode decodes ReportSumInfo from json.
func (s *ReportSumInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReportSumInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "item_name":
			if err := func() error {
				s.ItemName.Reset()
				if err := s.ItemName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_name\"")
			}
		case "count":
			if err := func() error {
				s.Count.Reset()
				if err := s.Count.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReportSumInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReportSumInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReportSumInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Service) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Service) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("ID")
			s.ID.Encode(e)
		}
	}
	{
		if s.OperationID.Set {
			e.FieldStart("OperationID")
			s.OperationID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("Price")
			s.Price.Encode(e)
		}
	}
}

var jsonFieldsNameOfService = [4]string{
	0: "ID",
	1: "OperationID",
	2: "Name",
	3: "Price",
}

// Decode decodes Service from json.
func (s *Service) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Service to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ID":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "OperationID":
			if err := func() error {
				s.OperationID.Reset()
				if err := s.OperationID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"OperationID\"")
			}
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "Price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Service")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Service) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Service) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SumServicesByDayParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SumServicesByDayParams) encodeFields(e *jx.Encoder) {
	{
		if s.Date.Set {
			e.FieldStart("date")
			s.Date.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfSumServicesByDayParams = [1]string{
	0: "date",
}

// Decode decodes SumServicesByDayParams from json.
func (s *SumServicesByDayParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SumServicesByDayParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "date":
			if err := func() error {
				s.Date.Reset()
				if err := s.Date.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SumServicesByDayParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SumServicesByDayParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SumServicesByDayParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VientoItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VientoItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Int64(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("price")
		e.Float64(s.Price)
	}
	{
		e.FieldStart("ean")
		e.Int64(s.Ean)
	}
}

var jsonFieldsNameOfVientoItem = [4]string{
	0: "id",
	1: "name",
	2: "price",
	3: "ean",
}

// Decode decodes VientoItem from json.
func (s *VientoItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VientoItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.ID = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "price":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Price = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "ean":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.Ean = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ean\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VientoItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVientoItem) {
					name = jsonFieldsNameOfVientoItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VientoItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VientoItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VientoProduct) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VientoProduct) encodeFields(e *jx.Encoder) {
	{
		if s.ProductID.Set {
			e.FieldStart("ProductID")
			s.ProductID.Encode(e)
		}
	}
	{
		if s.OfferID.Set {
			e.FieldStart("OfferID")
			s.OfferID.Encode(e)
		}
	}
	{
		if s.IsFBOVisible.Set {
			e.FieldStart("IsFBOVisible")
			s.IsFBOVisible.Encode(e)
		}
	}
	{
		if s.Archived.Set {
			e.FieldStart("Archived")
			s.Archived.Encode(e)
		}
	}
	{
		if s.IsFBSVisible.Set {
			e.FieldStart("IsFBSVisible")
			s.IsFBSVisible.Encode(e)
		}
	}
	{
		if s.IsDiscounted.Set {
			e.FieldStart("IsDiscounted")
			s.IsDiscounted.Encode(e)
		}
	}
	{
		if s.Barcode.Set {
			e.FieldStart("Barcode")
			s.Barcode.Encode(e)
		}
	}
	{
		if s.Barcodes != nil {
			e.FieldStart("Barcodes")
			e.ArrStart()
			for _, elem := range s.Barcodes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("Price")
			s.Price.Encode(e)
		}
	}
}

var jsonFieldsNameOfVientoProduct = [9]string{
	0: "ProductID",
	1: "OfferID",
	2: "IsFBOVisible",
	3: "Archived",
	4: "IsFBSVisible",
	5: "IsDiscounted",
	6: "Barcode",
	7: "Barcodes",
	8: "Price",
}

// Decode decodes VientoProduct from json.
func (s *VientoProduct) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VientoProduct to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ProductID":
			if err := func() error {
				s.ProductID.Reset()
				if err := s.ProductID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ProductID\"")
			}
		case "OfferID":
			if err := func() error {
				s.OfferID.Reset()
				if err := s.OfferID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"OfferID\"")
			}
		case "IsFBOVisible":
			if err := func() error {
				s.IsFBOVisible.Reset()
				if err := s.IsFBOVisible.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsFBOVisible\"")
			}
		case "Archived":
			if err := func() error {
				s.Archived.Reset()
				if err := s.Archived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Archived\"")
			}
		case "IsFBSVisible":
			if err := func() error {
				s.IsFBSVisible.Reset()
				if err := s.IsFBSVisible.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsFBSVisible\"")
			}
		case "IsDiscounted":
			if err := func() error {
				s.IsDiscounted.Reset()
				if err := s.IsDiscounted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsDiscounted\"")
			}
		case "Barcode":
			if err := func() error {
				s.Barcode.Reset()
				if err := s.Barcode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Barcode\"")
			}
		case "Barcodes":
			if err := func() error {
				s.Barcodes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Barcodes = append(s.Barcodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Barcodes\"")
			}
		case "Price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Price\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VientoProduct")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VientoProduct) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VientoProduct) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
